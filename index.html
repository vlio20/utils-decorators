<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Utils-Decorators</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link href="./site/tailwind.css" rel="stylesheet">
  <link href="./site/highlight.css" rel="stylesheet">

  <style>
    *, ::after, ::before {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .ud-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 4rem;
      padding: 0 1.2rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      z-index: 10;
    }

    .ud-toolbar .ud-header {
      font-size: 1.5rem;
      color: #5F5F5F;
    }

    .ud-toolbar .ud-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .ud-toolbar .ud-actions > span {
      position: relative;
      top: 5px;
    }

    .ud-menu-btn {
      display: none;
      position: relative;
      top: 2px;
      border: 0;
      background: transparent;
      outline: 0;
    }

    @media (max-width: 599px) {
      .ud-menu-btn {
        display: block;
      }
    }

    .ud-page-container {
      flex: 1;
      display: flex;
    }

    .ud-sidenav {
      width: 14rem;
      height: calc(100vh - 4rem);
      overflow: auto;
      background-color: white;
      border-right: 1px solid #F3F4F6;
      z-index: 5;
    }

    .ud-overlay {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      display: none;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1;
    }

    @media (max-width: 599px) {
      .ud-sidenav {
        position: fixed;
        transform: translateX(-100%);
      }

      .ud-nav-open .ud-sidenav {
        transform: translateX(0);
        transition: all 500ms;
      }

      .ud-nav-open .ud-overlay {
        display: block;
      }
    }

    .ud-sidenav li {
      height: 3.5rem;
      width: 100%;
      display: flex;
      align-items: center;
    }

    .ud-nav {
      border-bottom: 1px solid #F3F4F6;
    }

    .ud-nav:hover {
      background-color: #F3F4F6;
    }

    .ud-sidenav li > a,
    .ud-sidenav li > div {
      height: 100%;
      width: 100%;
      padding: 1rem;
    }

    .ud-sidenav li > a {
      padding-left: 1.5rem;
    }

    .ud-group {
      font-weight: bold;
    }

    .ud-main {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 4rem);
      overflow: auto;
    }

    .ud-section-title {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      background-color: #E5E7EB;
      color: #5F5F5F;
      font-size: 1.3rem;
      padding: 1.5rem;
    }

    .ud-section .ud-subtitle {
      font-weight: bold;
    }

    .ud-section-content {
      padding: 1.5rem;
    }

    .ud-description {
      margin-bottom: 1.5rem;
    }

    .ud-code-wrapper {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
      gap: 1.5rem;
    }

    @media (max-width: 599px) {
      .ud-code-wrapper {
        flex-direction: column;
      }
    }

    .ud-code-wrapper .ud-code-part {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 100%;
      overflow: auto;
    }

  </style>

</head>
<body>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZL8PJHMK5L"></script>

<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }

  gtag('js', new Date());

  gtag('config', 'G-ZL8PJHMK5L');
</script>


<div class="ud-toolbar">
  <span class="ud-header">utils-decorators</span>
  <div class="ud-actions">
    <a class="github-button" href="https://github.com/vlio20/utils-decorators" data-icon="octicon-star"
       data-show-count="true" aria-label="Star vlio20/utils-decorators on GitHub">Star</a>
    <button class="ud-menu-btn" onclick="toggleMenu()">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="black" width="24px" height="24px">
        <path d="M0 0h24v24H0z" fill="none"/>
        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
      </svg>
    </button>
  </div>
</div>
<div class="ud-page-container">
  <div class="ud-sidenav">
    <ul>
      <li class="ud-group">
        <div>General</div>
      </li>

      <li class="ud-nav">
        <a href="#install" onclick="logNavEvent('install')">Installation</a>
      </li>

      <li class="ud-group">
        <div>Decorators</div>
      </li>

      <li class="ud-nav">
        <a href="#after" onclick="logNavEvent('after')">after</a>
      </li>

      <li class="ud-nav">
        <a href="#before" onclick="logNavEvent('before')">before</a>
      </li>

      <li class="ud-nav">
        <a href="#cancelPrevious" onclick="logNavEvent('cancelPrevious')">cancel-previous</a>
      </li>

      <li class="ud-nav">
        <a href="#debounce" onclick="logNavEvent('debounce')">debounce</a>
      </li>

      <li class="ud-nav">
        <a href="#delay" onclick="logNavEvent('delay')">delay</a>
      </li>

      <li class="ud-nav">
        <a href="#delegate" onclick="logNavEvent('delegate')">delegate</a>
      </li>

      <li class="ud-nav">
        <a href="#execTime" onclick="logNavEvent('execTime')">execTime</a>
      </li>

      <li class="ud-nav">
        <a href="#memoize" onclick="logNavEvent('memoize')">memoize</a>
      </li>

      <li class="ud-nav">
        <a href="#memoizeAsync" onclick="logNavEvent('memoizeAsync')">memoizeAsync</a>
      </li>

      <li class="ud-nav">
        <a href="#multiDispatch" onclick="logNavEvent('multiDispatch')">multiDispatch</a>
      </li>

      <li class="ud-nav">
        <a href="#onError" onclick="logNavEvent('onError')">onError</a>
      </li>

      <li class="ud-nav">
        <a href="#rateLimit" onclick="logNavEvent('rateLimit')">rateLimit</a>
      </li>

      <li class="ud-nav">
        <a href="#readonly" onclick="logNavEvent('readonly')">readonly</a>
      </li>

      <li class="ud-nav">
        <a href="#refreshable" onclick="logNavEvent('refreshable')">refreshable</a>
      </li>

      <li class="ud-nav">
        <a href="#retry" onclick="logNavEvent('retry')">retry</a>
      </li>

      <li class="ud-nav">
        <a href="#throttle" onclick="logNavEvent('throttle')">throttle</a>
      </li>

      <li class="ud-nav">
        <a href="#throttleAsync" onclick="logNavEvent('throttleAsync')">throttleAsync</a>
      </li>

      <li class="ud-nav">
        <a href="#timeout" onclick="logNavEvent('timeout')">timeout</a>
      </li>
    </ul>
  </div>
  <div class="ud-main">
    <div class="ud-overlay" onclick="toggleMenu()"></div>
    <section class="ud-section">
      <div id="install"></div>
      <div class="ud-section-title">Installation</div>
      <div class="ud-section-content">
        <p class="ud-description">
          This library was highly inspired by lodash but uses decorators to implement its util methods.
          The lib can be used both in node and in web application, it is built to be <b>tree-shakable so you can use it
          even if you need a specific decorator</b>.

          To install the lib via npm please follow the command bellow:
        </p>
        <pre class="ud-code">
  npm i utils-decorators</pre>
      </div>
    </section>

    <section class="ud-section">
      <div id="after"></div>
      <div class="ud-section-title">After</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Invocation of the decorated method will cause execution of the provided function method after the invocation
          of the decorated method.
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface AfterConfig&lt;T = any, D = any&gt; {
    // the function (or the method name within the context) to invoke after the invocation of the decorated method
    func: keyof T | (args: ...any[]) => &lt;D&gt; ;

    // in case of a returned promise of the decorated method, should the after function wait for it to be resolved
    wait?: boolean;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Arguments to provided method:</div>
            <pre class="ud-code">
  interface AfterParams&lt;D = any&gt; {
    // the arguments that were provided to the decorated method
    args: any[];

    // the response data of the decorated method
    response: D;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { after } from 'utils-decorators';

  class Example1 {

    @after({
      func: 'after',
    })
    foo(x: number): number {
      return 42;
    }

    after(respData: AfterParams&lt;number&gt;): void {
      console.log(respData.args, respData.response);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { afterify } from 'utils-decorators';

  function foo = () => {
    console.log('original method called');
  }

  const fooWithAfter = afterify(foo, {
    func: (respData: AfterParams&lt;number&gt;) => {
        console.log(respData.args, respData.response);
    };
  });</pre>
          </div>
        </div>


        <div class="ud-subtitle">Decorator Example 2:</div>
        <pre class="ud-code">
  import { after } from 'utils-decorators';

  class Example2 {

    @after({
      func: (respData: AfterParams&lt;number&gt) => console.log(respData.args, respData.response),
      wait: true,
    })
    foo(x: number): Promise&lt;number&gt; {
      return this.numberProvider.getNumber(x);
    }
  }</pre>
      </div>
    </section>

    <section class="ud-section">
      <div id="before"></div>
      <div class="ud-section-title">Before</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Invocation of the decorated method will cause an execution of the provided function method before the
          invocation
          of the decorated method.
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface BeforeConfig&lt;T = any, D = any&gt; {
    // the function (or the method name within the context) to invoke before the invocation of the decorated method
    func: keyof T | (args: ...any[]) => &lt;D&gt; ;

    // in case of a returned promise of the decorated method, should the before function wait for it to be resolved
    wait?: boolean;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { before } from 'utils-decorators';

  class Example1 {

    @before({
      func: 'before',
    })
    foo(x: number): number {
      return 42;
    }

    before(): void {
      console.log('this will be invoked before');
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { beforify } from 'utils-decorators';

  function foo = () => {
    console.log('original method called');
  }

  const fooWithBefore = beforify(foo, {
    func: () => {
        console.log('this will be invoked before');
    };
  });</pre>
          </div>

        </div>


        <div class="ud-subtitle">Decorator Example 2:</div>
        <pre class="ud-code">
  import { before } from 'utils-decorators';

  class Example2 {

    @after({
      func: () => console.log('this will be invoked before');,
      wait: true,
    })
    foo(x: number): Promise&lt;number&gt; {
      return this.numberProvider.getNumber(x);
    }
  }</pre>
      </div>
    </section>

    <section class="ud-section">
      <div id="cancelPrevious"></div>
      <div class="ud-section-title">Cancel Previous</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Invocation of the decorated method will cause the a rejection of the previous invocation with an error of
          <i>CancelPromise</i> type.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { cancelPrevious } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @cancelPrevious()
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { cancelPreviousify } from 'utils-decorators';

  const dataProvider = cancelPreviousify(() => {
    return fetch(...);
  }));</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="debounce"></div>
      <div class="ud-section-title">Debounce</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Causes a delay in the invocation of the decorated method by given time (in ms), if during the delay another
          invocation will happen, the delay will be restarted.
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // the time (in milliseconds) to wait before invoke
  delay: number;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { debounce } from 'utils-decorators';

  class Example1 {

    @debounce(1000)
    foo(x: number): number {
      return 42;
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { debouncify } from 'utils-decorators';

  function foo(): void {
    console.log('will be debounced')
  }

  const debouncedFoo = debouncify(foo, 1000);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="delay"></div>
      <div class="ud-section-title">Delay</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Causes a delay in the invocation of the decorated method by given time (in ms).
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // the time (in milliseconds) to wait before invoke
  delay: number;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { delay } from 'utils-decorators';

  class Example1 {

    @delay(1000)
    foo(x: number): number {
      return 42;
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { delayfy } from 'utils-decorators';

  function foo(): void {
    console.log('will be delayed')
  }

  const delayedFoo = delayfy(foo, 1000);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="delegate"></div>
      <div class="ud-section-title">Delegate</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          For a given input, if within the time period of the resolving of the promise of the first invocation the
          decorated method was invoked multiple times (with the same input) the response would be the promise that was
          generated by the first invocation. This way this decorator reduces the amount of calls to the implementation
          of the decorated method, for example accessing the database.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // an optional function (or a function name within the context) that maps the arguments to a specific key.
  // The default mapping function is JSON.stringify(args).
  keyResolver?: string | (...args: any[]) => string;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { delegate } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @delegate()
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { delegatify } from 'utils-decorators';

  function getData(): Promise&lt;DataDto> {
    return dataProvider.getData();
  }

  const delegatedFoo = delegatify(getData);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with custom mapper):</div>
            <pre class="ud-code">
  import { delegate } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example2 {

    constructor(private readonly dataProvider: DataProvider) { }

    @delegate((x, y) => `${x}_${y}`)
    getData(x, y): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData(x, y);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with custom mapper):</div>
            <pre class="ud-code">
  import { delegatify } from 'utils-decorators';

  function getData(): Promise&lt;DataDto> {
    return dataProvider.getData();
  }

  const delegatedFoo = delegatify(getData, (x, y) => `${x}_${y}`);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="execTime"></div>
      <div class="ud-section-title">Exec-Time</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Measures the time that takes for the decorated method to respond.
          Also returns the original response.
          By default, will log the result using <i>console.info()</i> but this can be changed by providing your own
          reporter
          function.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Arguments to the reporter function:</div>
            <pre class="ud-code">
  interface ExactTimeReportData = {
    args: any[];
    result: any;
    execTime: number;
  };</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // an optional function (or a function name within the context) that receives <i>ExactTimeReportData</i>
  // (see details above) as an argument. If the decorated method returns a Promise,
  // the decorator will wait for it to be resolved/rejected.
  // The default report function is (data: ExactTimeReportData) => console.info(data.execTime)
  reporter?: string | (data: ExactTimeReportData) => any;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { execTime } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @execTime()
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { execTimify } from 'utils-decorators';

  function getData(): Promise&lt;DataDto> {
    return dataProvider.getData();
  }

  const measuredFoo = execTimify(getData);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with custom reporter):</div>
            <pre class="ud-code">
  import { execTime } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example2 {

    constructor(private readonly dataProvider: DataProvider) { }

    @execTime((data: ExactTimeReportData) => {
        console.log(data.args, data.result, data.execTime);
    })
    getData(x, y): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData(x, y);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with custom reporter):</div>
            <pre class="ud-code">
  import { delegatify } from 'utils-decorators';

  function getData(): Promise&lt;DataDto> {
    return dataProvider.getData();
  }

  const measuredFoo = execTimify(getData, (data: ExactTimeReportData) => {
    console.log(data.args, data.result, data.execTime);
  });</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="memoize"></div>
      <div class="ud-section-title">Memoize</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Memoizes the response that is being returned by the decorated method.
          Be default the key of the cached value will be the serialized <i>JSON.stringify</i> value of the provided
          arguments. You can supply your own key resolver.
          Also, you can provide your own cache, it has to implement the <i>Cache&lt;D&gt;</i> interface (see bellow), by
          default
          the decorator is using a simple <i>Map&lt;string, D&gt;</i>.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface MemoizeConfig&lt;T, D&gt; {
    // an optional cache object which should implement the Cache interface.
    // Internally the decorator is using Map&lt;string, D&gt;
    cache?: Cache&lt;D&gt;;

    // an optional function (or a function name within the context) that maps the arguments to a specific key.
    // The default mapping function is JSON.stringify(args).
    keyResolver?: string | (...args: any[]) => string;

    // An optional TTL (time to leave in milliseconds) for the entry to be removed from the cache.
    // If not provided the cache will be never cleared.
    expirationTimeMs?: number;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1 (cache with no ttl):</div>
            <pre class="ud-code">
  import { memoize } from 'utils-decorators';

  class Example1 {

    @memoize()
    fibo(n: number): number; {
      if (n &lt; 2) return 1;

      return this.fibo(n - 1) + this.fibo(n - 2);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1 (cache with no ttl):</div>
            <pre class="ud-code">
  import { memoizify } from 'utils-decorators';

  function fibo(n: number): number {
    if (n &lt; 2) return 1;

     return fibo(n - 1) + fibo(n - 2);
  );

  const memoizedFibo = memoizify(fibo);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with a ttl only):</div>
            <pre class="ud-code">
  import { memoize, Cache } from 'utils-decorators';

  class Example2 {

    // a one hour ttl
    @memoize(1000 * 60 * 60)
    fibo(n: number): number; {
      if (n &lt; 2) return 1;

      return this.fibo(n - 1) + this.fibo(n - 2);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with a ttl only):</div>
            <pre class="ud-code">
  import { memoizify } from 'utils-decorators';

  function fibo(n: number): number {
    if (n &lt; 2) return 1;

     return fibo(n - 1) + fibo(n - 2);
  );

  // a one hour ttl
  const memoizedFibo = memoizeify(fibo, 1000 * 60 * 60);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 3 (with a custom cache):</div>
            <pre class="ud-code">
  import { memoize, Cache } from 'utils-decorators';

  class CustomCache implements Cache&lt;number> {
    set: (key: string, value: number) => {...};
    get: (key: string) => number | null => {...}
    delete: (key: string) => void => {...}
    has: (key: string) => boolean => {...}
  }

  const customCache = new CustomCache();

  class Example3 {

    @memoize({
      cache: customCache
    })
    fibo(n: number): number; {
      if (n &lt; 2) return 1;

      return this.fibo(n - 1) + this.fibo(n - 2);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 3 (with a custom cache):</div>
            <pre class="ud-code">
  import { memoizify } from 'utils-decorators';

  const customCache: Cache&lt;number&gt; = {
    set: (key: string, value: number) => {...};
    get: (key: string) => number | null => {...}
    delete: (key: string) => void => {...}
    has: (key: string) => boolean => {...}
  }

  function fibo(n: number): number {
    if (n &lt; 2) return 1;

     return fibo(n - 1) + fibo(n - 2);
  );

  const memoizedFibo = memoizeify(fibo, {
    cache: customCache,
  });</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="memoizeAsync"></div>
      <div class="ud-section-title">Memoize Async</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Memoizes the promise that being returned by the decorated method.
          If the promise would be rejected, the promise won't be memoized.
          Another great feature of this decorator is that it delegates requests, for example if the same method has been
          called more than one time after the promise was resolved,
          only one invocation of the decorated method will be invoked.
          Be default the key of the cached value will be the serialized <i>JSON.stringify</i> value of the provided
          arguments.
          You can supply your own key resolver.
          Also, you can provide your own cache, it has to implement the <i>GetterSetter&lt;D&gt;</i> interface, by
          default the decorator is using a simple <i>Map&lt;string, Promise&lt;D>></i>.
          For further readying please read <a
            href="https://medium.com/swlh/caching-in-node-nestjs-web-applications-was-never-easier-1bb560c7cd62">this</a>
          blog post.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface MemoizeAsyncConfig&lt;T, D&gt; {
    // an optional cache object which should implement the Cache or the AsyncCache interface.
    // Internally the decorator is using Map&lt;string, D&gt;
    cache?: Cache&lt;D&gt;;

    // an optional function (or a function name within the context) that maps the arguments to a specific key.
    // The default mapping function is JSON.stringify(args).
    keyResolver?: string | (...args: any[]) => string;

    // An optional TTL (time to leave in milliseconds) for the entry to be removed from the cache.
    // If not provided the cache will be never cleared.
    expirationTimeMs?: number;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1 (cache with no ttl):</div>
            <pre class="ud-code">
  import { memoizeAsync } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @memoizeAsync()
    getData(): Promise&lt;DataDto>; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1 (cache with no ttl):</div>
            <pre class="ud-code">
  import { memoizeAsyncify } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const memoizedDataProvider = memoizeAsyncify(dataProvider);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with a ttl only):</div>
            <pre class="ud-code">
  import { memoizeAsync } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider';

  class Example2 {

    constructor(private readonly dataProvider: DataProvider) { }

    // a one hour ttl
    @memoizeAsync(1000 * 60 * 60)
    getData(): Promise&lt;DataDto>; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with a ttl only):</div>
            <pre class="ud-code">
  import { memoizeAsyncify, Cache } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  // a one hour ttl
  const memoizedDataProvider = memoizeAsyncify(dataProvider, 1000 * 60 * 60);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 3 (with a custom cache):</div>
            <pre class="ud-code">
  import { memoizeAsync, Cache } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider';

  class CustomCache implements Cache&lt;number> {
    set: (key: string, value: number) => {...};
    get: (key: string) => number | null => {...}
    delete: (key: string) => void => {...}
    has: (key: string) => boolean => {...}
  }

  const customCache = new CustomCache();

  class Example3 {

    constructor(private readonly dataProvider: DataProvider) { }

    @memoizeAsync({
        cache: customCache,
        expirationTimeMs: 1000 * 60 * 60,
    })
    getData(): Promise&lt;DataDto>; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 3 (with a custom cache):</div>
            <pre class="ud-code">
  import { memoizeAsyncify } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const customCache: Cache&lt;number> = {
    set: (key: string, value: number) => {...};
    get: (key: string) => number | null => {...}
    delete: (key: string) => void => {...}
    has: (key: string) => boolean => {...}
  }

  const memoizedDataProvider = memoizeAsyncify(dataProvider, {
      cache: customCache,
      expirationTimeMs: 1000 * 60 * 60,
  });</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 4 (with an async cache):</div>
            <pre class="ud-code">
  import { memoizeAsync, AsyncCache } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider';

  class CustomCache implements AsyncCache&lt;number> {
    set: (key: string, value: number): Promise&lt;void> => {...};
    get: (key: string) => Promise&lt;number | null> => {...}
    delete: (key: string) => Promise&lt;void> => {...}
    has: (key: string) => Promise&lt;boolean> => {...}
  }

  const customCache = new CustomCache();

  class Example4 {

    constructor(private readonly dataProvider: DataProvider) { }

    @memoizeAsync({
        cache: customCache,
        expirationTimeMs: 1000 * 60 * 60,
    })
    getData(): Promise&lt;DataDto>; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 4 (with an async cache):</div>
            <pre class="ud-code">
  import { memoizeAsyncify, AsyncCache } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const customCache: AsyncCache&lt;number> = {
    set: (key: string, value: number): Promise&lt;void> => {...};
    get: (key: string) => Promise&lt;number | null> => {...}
    delete: (key: string) => Promise&lt;void> => {...}
    has: (key: string) => Promise&lt;boolean> => {...}
  }

  const memoizedDataProvider = memoizeAsyncify(dataProvider, {
      cache: customCache,
      expirationTimeMs: 1000 * 60 * 60,
  });</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="multiDispatch"></div>
      <div class="ud-section-title">Multi Dispatch</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Will invoke the decorated method the amount of provided time in parallel. This decorator is useful when you
          want to increase the chance of the decorated method to return a value.
          Note that the fastest resolved promise will resolve the decorated method and in case where all dispatched will
          fail the last error would be of the last rejected promise.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // the amount of invocations to generate simultaneously
  dispatchesAmount: number;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { multiDispatch } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @multiDispatch(2)
    getData(): Promise&lt;DataDto> {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { multiDispatchify } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const multiDispatchedDataProvider = multiDispatchify(dataProvider.getData, 2);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="onError"></div>
      <div class="ud-section-title">On Error</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          This decorator will catch errors thrown from the decorated method and invoke the provided `func` function.
          If the decorated method returns a <i>Promise</i> the <i>wait</i> property should be set to true in order to
          handle the
          promise rejection correctly.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface OnErrorConfig&lt;T = any, D = any&gt; {
    // the function (or the method name within the context) to invoke on an error of the decorated method
    func: keyof T | (args: ...any[]) => &lt;D&gt; ;
  }</pre>
          </div>
        </div>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { onError } from 'utils-decorators';

  class Example1 {

    @onError({
      func: 'errorHandler',
    })
    foo(x: number): Promise&lt;number&gt; {
      return doSomething();
    }

    errorHandler(e: Error): void {
      console.error(e);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { onErrorify } from 'utils-decorators';

  const wrappedFunction = onErrorify(
    () => {
      doSomething();
    },
    {
      func: console.error,
    }
  );</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="rateLimit"></div>
      <div class="ud-section-title">Rate Limit</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Limits the amount of calls to the decorated method in a given time period. This decorator can support both
          local (in-memory) counter or a distributed one.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface RateLimitConfigs&lt;T = any> {
    // the time window for which the rate-limit should hold the counts (time in milliseconds)
    timeSpanMs: number;

    // the amount of call allowed in the provided timeSpanMs.
    allowedCalls: number;

    // Sometimes you want to group your calls and only then apply the rate-limit.
    // By providing the keyResolver you can group your calls by the provided arguments.
    // You should supply here an optional function (or the method name within the context) which will be invoked to get
    // in order to get a key
    keyResolver?: keyof T | (...args: any[]) => string;

    // An optional custom rate limit counter, note that you can only provide rateLimitCounter
    // or rateLimitAsyncCounter - not both
    rateLimitCounter?: RateLimitCounter;

    // An optional custom async rate limit counter, note that you can only provide rateLimitCounter
    // or rateLimitAsyncCounter - not both
    rateLimitAsyncCounter?: RateLimitAsyncCounter;

    // An optional custom handler which will be invoked when the amount of calls has exceeds,
    // By default the decorator will throw an Error
    exceedHandler?: () => void;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { rateLimit } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @rateLimit({
      timeSpanMs: 2000,
      allowedCalls: 10,
    })
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { rateLimitify } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const delegatedFoo = rateLimitify(dataProvider.getData, {
    timeSpanMs: 2000,
    allowedCalls: 10,
  });</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with custom keyResolver):</div>
            <pre class="ud-code">
  import { rateLimit } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @rateLimit({
      timeSpanMs: 2000,
      allowedCalls: 10,
      keyResolver: 'groupCalls',
    })
    getData(userId: number): Promise&lt;DataDto&gt; {
      return this.dataProvider.getUserData(userId);
    }

    groupCalls(userId: number): string {
      return userId.toString();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with custom keyResolver):</div>
            <pre class="ud-code">
  import { rateLimitify } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const delegatedFoo = rateLimitify(dataProvider.getUserData, {
    timeSpanMs: 2000,
    allowedCalls: 10,
    keyResolver: (userId: number) => {
      return userId.toString();
    },
  });</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 3 (with custom rate limit counter):</div>
            <pre class="ud-code">
  import { rateLimit, RateLimitCounter } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class CustomCounter implements RateLimitCounter {
    inc: (key: string): void => { ... };
    dec: (key: string): void => { ... };
    getCount: (key: string): number => { ... };
  }

  const customCounter = new CustomCounter();

  class Example3 {

    constructor(private readonly dataProvider: DataProvider) { }

    @rateLimit({
      timeSpanMs: 2000,
      allowedCalls: 10,
      rateLimitCounter: customCounter,
    })
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 3 (with custom rate limit counter):</div>
            <pre class="ud-code">
  import { rateLimitify, RateLimitCounter } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const customCounter: RateLimitCounter = {
    inc: (key: string): void => { ... };
    dec: (key: string): void => { ... };
    getCount: (key: string): number => { ... };
  }

  const delegatedFoo = rateLimitify(dataProvider.getData, {
    timeSpanMs: 2000,
    allowedCalls: 10,
    rateLimitCounter: customCounter,
  });</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 4 (with custom async rate limit counter):</div>
            <pre class="ud-code">
  import { rateLimit, RateLimitAsyncCounter } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class CustomCounter implements RateLimitAsyncCounter {
    inc: (key: string): Promise&lt;void> => { ... };
    dec: (key: string): Promise&lt;void> => { ... };
    getCount: (key: string): Promise&lt;number> => { ... };
  }

  const customCounter = new CustomCounter();

  class Example4 {

    constructor(private readonly dataProvider: DataProvider) { }

    @rateLimit({
      timeSpanMs: 2000,
      allowedCalls: 10,
      rateLimitAsyncCounter: customCounter,
    })
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 4 (with custom async rate limit counter):</div>
            <pre class="ud-code">
  import { rateLimitify, RateLimitAsyncCounter } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const customCounter: RateLimitAsyncCounter = {
    inc: (key: string): Promise&lt;void> => { ... },
    dec: (key: string): Promise&lt;void> => { ... },
    getCount: (key: string): Promise&lt;number> => { ... },
  }

  const delegatedFoo = rateLimitify(dataProvider.getData, {
    timeSpanMs: 2000,
    allowedCalls: 10,
    rateLimitAsyncCounter: customCounter,
  });</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 5 (with custom exceedHandler):</div>
            <pre class="ud-code">
  import { rateLimit } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @rateLimit({
      timeSpanMs: 2000,
      allowedCalls: 10,
      exceedHandler: 'handler',
    })
    getData(userId: number): Promise&lt;DataDto&gt; {
      return this.dataProvider.getUserData(userId);
    }

    handler(): void {
      throw new Error('too much call in allowed window');
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 5 (with custom exceedHandler):</div>
            <pre class="ud-code">
  import { rateLimitify } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const delegatedFoo = rateLimitify(dataProvider.getUserData, {
    timeSpanMs: 2000,
    allowedCalls: 10,
    exceedHandler: (userId: number) => {
      throw new Error('too much call in allowed window');
    },
  });</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="readonly"></div>
      <div class="ud-section-title">Readonly</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          This decorator prevents setting new values to decorated property.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { readonly } from 'utils-decorators';

  class Example1 {

    @readonly()
    userId: number = 100;
  }</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="refreshable"></div>
      <div class="ud-section-title">Refreshable</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          This decorator provides an ability to access a property which value is being updated over and over in a given
          interval (in ms) by the returned value of the provided method. Note that the method can also return a promise
          which will be resolved after each interval.
          In order to cancel the refreshment of the data you need to set the decorated value to null (this is very
          important note to prevent memory leaks). Setting any other value will be ignored.
          Another important note is that the initial value of the decorated attribute must not be <i>null</i>. Any other
          value should be fine.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // the amount of invocations to generate simultaneously
  interface RefreshableConfig&lt;D> {
    // the function that will provide the data to the decorated attribute
    dataProvider: AsyncMethod&lt;D>;

    // the time interval (in milliseconds) in which the data will be refreshed
    intervalMs: number;
  }
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { refreshable } from 'utils-decorators';
  import { userProvider, UserDto } from 'user.service';

  class Example1 {

    @refreshable({
        dataProvider: userProvider.getUsers,

        // 10 minuts
        intervalMs: 1000 * 60 * 10
    })
    users: UserDto[];
  }</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="retry"></div>
      <div class="ud-section-title">Retry</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Retries execution of the decorated method. The method will be invoked x + 1 times (where x is the retries
          values) in the worst case (when all invocation failed).
          You can provide you own delay time (or delay times array) between the invocations - see details below. Note
          that the default delay between retries is 1000ms.
          You can also provide an onRetry callback function (or name of the method in the decorated class). This
          callback
          will be invoked before every retry call.
          Note that if you are providing a RetryInputConfig, you can pass retries and delay (if not provided than will
          use the default 1000ms delay) or delaysArray but not both.
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  type RetryInput = number | number[] | RetryInputConfig;

  export interface RetryInputConfig {
    delaysArray?: number[];
    retries?: number;
    delay: number;
    onRetry?: OnRetry | string;
  }

  export type OnRetry = (error: Error, retriesCount: number) => void;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { retry } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @retry(3)
    getData(): DataDto {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { retryfy } from 'utils-decorators';
  import { getData } from './data-provider';

  const retriedGetData = retryfy(getData, 3);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with delays array):</div>
            <pre class="ud-code">
  import { retry } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider';

  class Example2 {

    constructor(private readonly dataProvider: DataProvider) { }

    @retry([1000, 2000, 3000])
    getData(): DataDto {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with delays array):</div>
            <pre class="ud-code">
  import { retryfy } from 'utils-decorators';
  import { getData } from './data-provider';

  const retriedGetData = retryfy(getData, [1000, 2000, 3000]);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 3 (with configuration object):</div>
            <pre class="ud-code">
  import { retry } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider';

  class Example2 {

    constructor(private readonly dataProvider: DataProvider) { }

    @retry({
      retries: 3,
      delay: 1500,
      onRetry: (e, retriesCount) => console.log(e, retriesCount),
    })
    getData(): DataDto {
      return this.dataProvider.getData();
    }

    @retry({
      retries: 3,
      delay: 1500,
      onRetry: 'onRetry',
    })
    getData2(): DataDto {
      return this.dataProvider.getData();
    }

    onRetry(e: Error, retriesCount: number) {
      console.log(e, retriesCount);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 3 (with configuration object):</div>
            <pre class="ud-code">
  import { retryfy } from 'utils-decorators';
  import { getData } from './data-provider';

  const retriedGetData = retryfy(getData, {
    retries: 3,
    delay: 1500,
    onRetry: (e, retriesCount) => console.log(e, retriesCount),
  });</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="throttle"></div>
      <div class="ud-section-title">Throttle</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Invocation of the decorated method will happen immediately, but if another invocation of this method will
          happen during the provided time (in ms) it will be ignored.
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // the time (in milliseconds) to delay the invocation between the calls
  delayMs: number;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { throttle } from 'utils-decorators';

  class Example1 {

    @throttle(1000)
    foo(x: number): number {
      return 42;
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { throttlify } from 'utils-decorators';

  function foo(): void {
    console.log('will be throttled')
  }

  const delayedFoo = throttlify(foo, 1000);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="throttleAsync"></div>
      <div class="ud-section-title">Throttle Async</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          For a given limit, the decorator will invoke the decorated method jus the allowed times. Once one of the
          promises will be resolved the next call in queue will be invoked,
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // The limit of allowed concurrent calls
  limit: number;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { throttleAsync } from 'utils-decorators';
  import { DataProvider, DataDto }

  class Example1 {
    constructor(private readonly dataProvider: DataProvider) { }

    @throttleAsync(2)
    getData(): DataDto {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { throttleAsyncify } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const throttledDataProvider = throttleAsyncify(dataProvider.getData, 3);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="timeout"></div>
      <div class="ud-section-title">Timeout</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Will throw an error (<i>TimeoutError</i>) if the decorated method returned promise won't be resolved withing
          the provided timeout (timeout is in milliseconds).
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // time in milliseconds for waiting for the promise to be resolved
  ms: number;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { timeout } from 'utils-decorators';
  import { DataProvider, DataDto }

  class Example1 {
    constructor(private readonly dataProvider: DataProvider) { }

    @timeout(2000)
    getData(): DataDto {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { timeoutify } from 'utils-decorators';
  import { dataProvider } from './data-provider';

  const dataProviderWithTimeout = timeoutify(dataProvider.getData, 2000);</pre>
          </div>
        </div>
      </div>
    </section>
  </div>
</div>
<script src="./site/highlight.js"></script>
<script>
  const body = document.querySelector('body');

  addEventListener('load', () => {
    document.querySelectorAll('pre.ud-code')
      .forEach(block => {
        hljs.highlightBlock(block);
      });
  });

  document.querySelectorAll('.ud-sidenav a').forEach(item => {
    item.addEventListener('click', event => {
      if (body.classList.contains('ud-nav-open')) {
        toggleMenu();
      }
    })
  })

  function toggleMenu() {
    if (body.classList.contains('ud-nav-open')) {
      body.classList.remove('ud-nav-open');
    } else {
      body.classList.add('ud-nav-open');
    }
  }

  function logNavEvent(event) {
    if (gtag) {
      gtag('event', 'navigation', {
        'event_category': event,
      });
    }
  }
</script>

<script async defer src="https://buttons.github.io/buttons.js"></script>
</body>
</html>

